using XmlSourceGenerator;
using XmlSourceGenerator.Generators;
using XmlSourceGenerator.Models;
using TallyConnector.TDLReportSourceGenerator.Models;
using TallyConnector.TDLReportSourceGenerator.Services.AttributeTransformers.Property;

namespace TallyConnector.TDLReportSourceGenerator.Services;

internal class PostDTOGenerator
{
    private ClassData _modelData;
    private SourceProductionContext _context;
    private CancellationToken token;

    public PostDTOGenerator(ClassData modelData, SourceProductionContext context, CancellationToken token)
    {
        _modelData = modelData;
        _context = context;
        this.token = token;
    }


    public PostDTOGenerator GenerateDTO()
    {
        //if (_modelData.IsEnum) 
        //{
        //    return this;
        //}

        ClassDeclarationSyntax classDeclarationSyntax = ClassDeclaration(_modelData.DTOName)
                  .WithModifiers(TokenList([Token(
                            TriviaList(
                                Comment($@"/*
* Generated based on {_modelData.FullName}
*/")),
                            SyntaxKind.PublicKeyword,
                            TriviaList()),Token(SyntaxKind.PartialKeyword)]))
                     .WithBaseList(
                    BaseList(
                        SingletonSeparatedList<BaseTypeSyntax>(
                            SimpleBaseType(
                              _modelData.BaseData == null ? IdentifierName(Constants.Models.Abstractions.MetaObjectypeName) : GetGlobalNameforType(_modelData.BaseData.DTOFullName)))));


        classDeclarationSyntax = classDeclarationSyntax.WithAttributeLists(
            SingletonList<AttributeListSyntax>(
                AttributeList(
                    SeparatedList<AttributeSyntax>(
                        new SyntaxNodeOrToken[]{
                            Attribute(
                                IdentifierName("XmlRoot"))
                            .WithArgumentList(
                                AttributeArgumentList(
                                    SingletonSeparatedList<AttributeArgumentSyntax>(
                                        AttributeArgument(
                                            LiteralExpression(
                                                SyntaxKind.StringLiteralExpression,
                                                Literal(_modelData.XMLTag)))))),
                            Token(SyntaxKind.CommaToken),
                            Attribute(
                               IdentifierName("XmlType"))
                            .WithArgumentList(
                               AttributeArgumentList(
                                   SingletonSeparatedList<AttributeArgumentSyntax>(
                                       AttributeArgument(
                                           LiteralExpression(
                                               SyntaxKind.TrueLiteralExpression))
                                       .WithNameEquals(
                                           NameEquals(
                                               IdentifierName("AnonymousType")))))),
                            //Token(SyntaxKind.CommaToken),
                            //Attribute(
                            //    IdentifierName("XmlSourceGenerator.Abstractions.XmlAutoGenerated"))
                        }))));
        var unit = CompilationUnit()
          .WithUsings(List(GetUsings()))
          .WithMembers(List(new MemberDeclarationSyntax[]
          {
                FileScopedNamespaceDeclaration(IdentifierName($"{_modelData.Namespace}.DTO"))
                .WithNamespaceKeyword(Token(TriviaList(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword),true))),
                                            SyntaxKind.NamespaceKeyword,
                                            TriviaList()))
                .WithMembers(List(new MemberDeclarationSyntax[]
                {
                    classDeclarationSyntax
                    .WithMembers(List(GetClassMembers()))
                }))
          })).NormalizeWhitespace().ToFullString();
        _context.AddSource($"PostDTO.{_modelData.Name}_{_modelData.Namespace}.g.cs", unit);

        GenerateXmlMethods();

        return this;
    }

    private void GenerateXmlMethods()
    {
        var generatorModel = MapToGeneratorTypeModel(_modelData);
        var sb = new IndentedStringBuilder();

        // Usings
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Xml;");
        sb.AppendLine("using System.Xml.Linq;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine("using XmlSourceGenerator.Abstractions;");
        sb.AppendLine();

        sb.AppendLine($"namespace {_modelData.Namespace}.DTO");
        sb.AppendLine("{");
        using (sb.Indent())
        {
            sb.AppendLine($"public partial class {_modelData.DTOName} : IXmlStreamable");
            sb.AppendLine("{");

            using (sb.Indent())
            {
                 // Generate nested XmlTypeInfo class
                sb.AppendLine("private static class XmlTypeInfo");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    sb.AppendLine($"public static readonly Type Type = typeof({_modelData.DTOName});");
                    foreach (var prop in generatorModel.Properties)
                    {
                         sb.AppendLine($"public const string PropName_{prop.Name} = \"{prop.Name}\";");
                         sb.AppendLine($"public const string DefaultXmlName_{prop.Name} = \"{prop.XmlElementName ?? prop.Name}\";");
                    }
                }
                sb.AppendLine("}");

                string rootName = !string.IsNullOrEmpty(_modelData.XMLTag) ? _modelData.XMLTag : _modelData.Name;
                sb.AppendLine($"public string DefaultXmlRootElementName => \"{rootName}\";");
                // ReadFromXml is not supported for DTOs
                sb.AppendLine("public void ReadFromXml(XElement element, XmlSerializationOptions options = null)");
                sb.AppendLine("{");
                using (sb.Indent())
                {
                    sb.AppendLine("throw new NotImplementedException();");
                }
                sb.AppendLine("}");
                sb.AppendLine();
                new XmlWriteGenerator(sb).GenerateWriteMethod(generatorModel);
            }
            sb.AppendLine("}");
        }
        sb.AppendLine("}");

        _context.AddSource($"PostDTO.Xml.{_modelData.Name}_{_modelData.Namespace}.g.cs", sb.ToString());
    }
    private IEnumerable<MemberDeclarationSyntax> GetClassMembers()
    {
        List<MemberDeclarationSyntax> members = [];
        if (_modelData.Symbol.CheckBaseClass(Constants.Models.BaseMasterObjectFullName) && !_modelData.Symbol.CheckBaseClass(Constants.Models.BaseAliasedMasterObjectFullName))
        {
            List<SyntaxNodeOrToken> attributes = [];
            attributes.SafeAdd(Attribute(GetGlobalNameforType(XMLElementAttributeName))
          .WithArgumentList(AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(
                                          [AttributeArgument(CreateStringLiteral("NAME"))]))));
            PropertyDeclarationSyntax propertyDeclarationSyntax = PropertyDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), "NewName")
                .WithAccessorList(
            AccessorList(
                List(
                    [
                        AccessorDeclaration(
                            SyntaxKind.GetAccessorDeclaration)
                        .WithSemicolonToken(
                            Token(SyntaxKind.SemicolonToken)),
                        AccessorDeclaration(
                            SyntaxKind.SetAccessorDeclaration)
                        .WithSemicolonToken(
                            Token(SyntaxKind.SemicolonToken))])))
                .WithModifiers(TokenList([Token(SyntaxKind.PublicKeyword)]))
                .WithAttributeLists(List(
                         [
                             AttributeList( SeparatedList<AttributeSyntax>(attributes))
                         ]));
            members.Add(propertyDeclarationSyntax);
        }
        foreach (var item in _modelData.Members)
        {
            List<SyntaxNodeOrToken> attributes = [];
            var member = item.Value;
            if (member.IgnoreForDTO || member.XmlIgnore) continue;
            List<SyntaxToken> tokens = [Token(SyntaxKind.PublicKeyword)];
            if (member.IsOverridenProperty)
            {
                tokens.Add(Token(SyntaxKind.NewKeyword));
            }
            TypeSyntax NameSyntax = PredefinedType(Token(SyntaxKind.StringKeyword));
            if (member.IsComplex && !member.IsTallyComplexObject)
            {
                if (member.ClassData != null)
                {
                    var typeName = member.ClassData.DTOName;
                    NameSyntax = GetGlobalNameforType($"{member.ClassData.Namespace}.DTO.{typeName}");

                }
            }
            if (member.IsList)
            {
                NameSyntax = GenericName(Identifier(ListClassName), TypeArgumentList([NameSyntax]));
            }
            if (member.IsNullable) NameSyntax = NullableType(NameSyntax);

            string attributeName = XMLElementAttributeName;
            if (member.IsAttribute)
            {
                attributeName = XMLAttributeAttributeName;
            }
            else if (member.IsList && member.ListXMLTag != null)
            {
                attributeName = XMLArrayItemAttributeName;
                attributes.SafeAdd(Attribute(GetGlobalNameforType(XMLArrayAttributeName))
               .WithArgumentList(AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(
                                               new SyntaxNodeOrToken[] { AttributeArgument(CreateStringLiteral(member.ListXMLTag)) }))));
            }
            List<SyntaxNodeOrToken> attributeArgs = [AttributeArgument(CreateStringLiteral(member.DefaultXMLData?.XmlTag ?? member.Name.ToUpper()))];
            if (member.XMLData.Count > 0 && member.ClassData != null)
            {
                attributeArgs.SafeAdd(AttributeArgument(TypeOfExpression(
                                                                GetGlobalNameforType(member.ClassData.DTOFullName)))
                                                        .WithNameEquals(
                                                            NameEquals(
                                                                IdentifierName("Type"))));
            }

            attributes.SafeAdd(Attribute(GetGlobalNameforType(attributeName))
                .WithArgumentList(AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(
                                                attributeArgs))));
            foreach (var xmlData in member.XMLData)
            {
                if (xmlData.ClassData == null)
                {
                    continue;
                }
                attributes.SafeAdd(Attribute(GetGlobalNameforType(XMLElementAttributeName))
                    .WithArgumentList(AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(
                                                [
                        AttributeArgument(CreateStringLiteral(xmlData.XmlTag ?? member.Name.ToUpper())),
                         Token(SyntaxKind.CommaToken),
                         AttributeArgument(
                                         TypeOfExpression(
                                             GetGlobalNameforType(xmlData.ClassData.DTOFullName)))
                                     .WithNameEquals(
                                         NameEquals(
                                     IdentifierName("Type")))
                                                ]))));
            }
            PropertyDeclarationSyntax propertyDeclarationSyntax = PropertyDeclaration(NameSyntax, item.Key)
                .WithAccessorList(
            AccessorList(
                List(
                    [
                        AccessorDeclaration(
                            SyntaxKind.GetAccessorDeclaration)
                        .WithSemicolonToken(
                            Token(SyntaxKind.SemicolonToken)),
                        AccessorDeclaration(
                            SyntaxKind.SetAccessorDeclaration)
                        .WithSemicolonToken(
                            Token(SyntaxKind.SemicolonToken))])))
                .WithModifiers(TokenList(tokens))
                .WithAttributeLists(List(
                         [
                             AttributeList( SeparatedList<AttributeSyntax>(attributes))
                         ]));



            members.Add(propertyDeclarationSyntax);

        }
        members.Add(GetImplicitConverterSyntax());



        return members;
    }



    private MemberDeclarationSyntax GetImplicitConverterSyntax()
    {
        List<StatementSyntax> statements = [];
        const string srcParameterName = "src";
        const string dtoVarName = "dto";

        statements.Add(IfStatement(
                    BinaryExpression(
                        SyntaxKind.EqualsExpression,
                        IdentifierName(srcParameterName),
                        LiteralExpression(
                            SyntaxKind.NullLiteralExpression)),
                    Block(
                        SingletonList<StatementSyntax>(
                            ReturnStatement(
                                LiteralExpression(
                                    SyntaxKind.NullLiteralExpression))))));

        statements.Add(LocalDeclarationStatement(
                    VariableDeclaration(
                        IdentifierName(
                            Identifier(
                                TriviaList(),
                                SyntaxKind.VarKeyword,
                                "var",
                                "var",
                                TriviaList())))
                    .WithVariables(
                        SingletonSeparatedList(
                            VariableDeclarator(
                                Identifier(dtoVarName))
                            .WithInitializer(
                                EqualsValueClause(
                                    ObjectCreationExpression(
                                        IdentifierName(_modelData.DTOName))
                                    .WithArgumentList(
                                        ArgumentList())))))));

        if (_modelData.Symbol.CheckBaseClass(Constants.Models.BaseMasterObjectFullName) && !_modelData.Symbol.CheckBaseClass(Constants.Models.BaseAliasedMasterObjectFullName))

        {
            statements.Add(ExpressionStatement(
                    AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(dtoVarName),
                            IdentifierName("NewName")),
                        MemberAccessExpression(
                             SyntaxKind.SimpleMemberAccessExpression,
                             IdentifierName(srcParameterName),
                             IdentifierName("Name")))));
        }
        AssignAllMembers();

        if (_modelData.Symbol.CheckBaseClass(Constants.Models.BaseAliasedMasterObjectFullName))
        {
            statements.Add(ExpressionStatement(InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(dtoVarName), IdentifierName("SetLanguageNameListAndAlias")))
                .WithArgumentList(ArgumentList([Argument(IdentifierName($"{srcParameterName}.Alias"))]))));
        }
        if (_modelData.Symbol.CheckInterface(VoucherObjectInterfaceName))
        {
            statements.Add(ExpressionStatement(
                   AssignmentExpression(
                       SyntaxKind.SimpleAssignmentExpression,
                       MemberAccessExpression(
                           SyntaxKind.SimpleMemberAccessExpression,
                           IdentifierName(dtoVarName),
                           IdentifierName("DateAttr")),
                        MemberAccessExpression(
                             SyntaxKind.SimpleMemberAccessExpression,
                             IdentifierName(dtoVarName),
                             IdentifierName("Date")))));
            MemberAccessExpressionSyntax masterIdMember = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(srcParameterName), IdentifierName("MasterId"));
            statements.Add(IfStatement(BinaryExpression(
                    SyntaxKind.NotEqualsExpression,
                    masterIdMember,
                    LiteralExpression(
                        SyntaxKind.NumericLiteralExpression,
                        Literal(0))),
                        Block(ExpressionStatement(
                        InvocationExpression(
                            IdentifierName($"{dtoVarName}.SetMasterIdasTagValue"))
                        .WithArgumentList(
                            ArgumentList(SeparatedList<ArgumentSyntax>(
                                    new SyntaxNodeOrToken[]{
                                        Argument(masterIdMember)}))))),
                        ElseClause(Block(ExpressionStatement(
                        InvocationExpression(
                            IdentifierName($"{dtoVarName}.SetVoucherNumberasTagValue"))
                        .WithArgumentList(
                            ArgumentList(SeparatedList<ArgumentSyntax>(
                                    new SyntaxNodeOrToken[]{
                                        Argument(IdentifierName($"{srcParameterName}.VoucherType")),
                                     Token(SyntaxKind.CommaToken),   Argument(IdentifierName($"{srcParameterName}.VoucherNumber")),}))))))));
        }
        statements.Add(ReturnStatement(IdentifierName(dtoVarName)));
        var declaration = ConversionOperatorDeclaration(
           Token(SyntaxKind.ImplicitKeyword),
           IdentifierName(_modelData.DTOName))
               .WithModifiers(
            TokenList(
                [
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)]))
            .WithParameterList(ParameterList(SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[]
            {
                Parameter(Identifier(srcParameterName)).WithType(GetGlobalNameforType(_modelData.FullName))
            })))
            .WithBody(Block(statements));


        void AssignAllMembers()
        {
            foreach (var item in _modelData.AllDirectMembers)
            {
                var member = item.Value;
                if (member.IgnoreForDTO || member.XmlIgnore) continue;
                ExpressionSyntax right = MemberAccessExpression(
                             SyntaxKind.SimpleMemberAccessExpression,
                             IdentifierName(srcParameterName),
                             IdentifierName(member.Name));

                if (member.IsComplex)
                {
                    if (member.ClassData == null) continue;
                    if (member.ClassData.IsTallyComplexObject)
                    {

                        if (member.IsNullable)
                        {
                            right = ConditionalAccessExpression(right, InvocationExpression(MemberBindingExpression(IdentifierName("ToString"))));
                        }
                        else
                        {
                            right = InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, right, IdentifierName("ToString")));
                        }

                    }
                    else
                    {
                        if (member.IsList)
                        {
                            ExpressionSyntax rightSelect;
                            if (member.XMLData.Count > 0)
                            {
                                List<SyntaxNodeOrToken> swichArm = [];
                                foreach (var xmlData in member.XMLData)
                                {
                                    if (xmlData.ClassData == null) continue;
                                    swichArm.SafeAdd(SwitchExpressionArm(DeclarationPattern(
                                                                                GetGlobalNameforType(xmlData.ClassData.FullName),
                                                                                SingleVariableDesignation(
                                                                                    Identifier("src"))),
                                                                            CastExpression(
                                                                                GetGlobalNameforType(xmlData.ClassData.DTOFullName),
                                                                                IdentifierName("src"))));
                                }
                                swichArm.SafeAdd(SwitchExpressionArm(
                                                                        DiscardPattern(),
                                                                        CastExpression(
                                                                            IdentifierName(member.ClassData.DTOFullName),
                                                                            IdentifierName("c"))));
                                rightSelect = InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                                                              right,
                                                                              IdentifierName("Select")))
                                     .WithArgumentList(ArgumentList(SingletonSeparatedList<ArgumentSyntax>(
                                                             Argument(
                                                                 SimpleLambdaExpression(
                                                                     Parameter(
                                                                         Identifier("c")))
                                                                 .WithExpressionBody(
                                                                    SwitchExpression(IdentifierName("c")).WithArms(SeparatedList<SwitchExpressionArmSyntax>(
                                                               swichArm)))))));
                            }
                            else
                            {

                                rightSelect = InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                                                              right,
                                                                              IdentifierName("Select")))
                                     .WithArgumentList(ArgumentList(SingletonSeparatedList<ArgumentSyntax>(
                                                             Argument(
                                                                 SimpleLambdaExpression(
                                                                     Parameter(
                                                                         Identifier("c")))
                                                                 .WithExpressionBody(
                                                                     CastExpression(
                                                                        GetGlobalNameforType(member.ClassData.DTOFullName),
                                                                         IdentifierName("c")))))));

                            }
                            var rightCollection = CollectionExpression(SeparatedList<CollectionElementSyntax>(SeparatedList<CollectionElementSyntax>(new SyntaxNodeOrToken[] { SpreadElement(rightSelect) })));
                            right = ConditionalExpression(IsPatternExpression(right,
                                                                              ConstantPattern(LiteralExpression(SyntaxKind.NullLiteralExpression))),
                                                                               LiteralExpression(SyntaxKind.NullLiteralExpression), rightCollection);
                        }
                        else
                        {
                            right = CastExpression(GetGlobalNameforType(member.ClassData.DTOFullName), right);
                        }
                    }

                }
                else
                {
                    switch (member.PropertyOriginalType.SpecialType)
                    {
                        case SpecialType.System_String:
                            break;
                        case SpecialType.System_DateTime or SpecialType.System_Boolean:
                            right = InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, right, IdentifierName("ToTallyString")));
                            break;
                        default:
                            right = InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, right, IdentifierName(member.IsEnum ? "ToTallyString" : "ToString")));
                            break;
                    }

                }

                statements.Add(ExpressionStatement(
                    AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(dtoVarName),
                            IdentifierName(member.Name)),
                        right)));
            }
        }

        return declaration;
    }

    private static List<UsingDirectiveSyntax> GetUsings()
    {
        return [
            UsingDirective(IdentifierName(ExtensionsNameSpace)),
            UsingDirective(IdentifierName(TallyConnectorRequestModelsNameSpace)),
            UsingDirective(IdentifierName(Constants.Models.Abstractions.PREFIX)),
            UsingDirective(IdentifierName("System.Xml.Linq")),
            UsingDirective(IdentifierName("System.Globalization")),
            //UsingDirective(IdentifierName("XmlSourceGenerator.Abstractions")),
            //UsingDirective(IdentifierName("XmlSourceGenerator.Helpers"))
        ];
    }

    private GeneratorTypeModel MapToGeneratorTypeModel(ClassData data)
    {
        var properties = new List<GeneratorPropertyModel>();

        // Identify base classes that are mapped to Custom DTOs
        // Properties from these classes should be IGNORED in AllDirectMembers
        // because we will add the corresponding DTO properties via GetCustomDTOProperties
        var ignoredBaseTypes = new HashSet<string>();
        var currentBase = data.BaseData;
        while (currentBase != null)
        {
            if (currentBase.DTOSymbol != null)
            {
                ignoredBaseTypes.Add(currentBase.FullName);
            }
            currentBase = currentBase.BaseData;
        }

        // Use AllDirectMembers to include inherited properties from the Model hierarchy
        foreach (var member in data.AllDirectMembers.Values)
        {
            if (member.IgnoreForDTO || member.XmlIgnore) continue;

            // Check if this member belongs to an ignored base type
             if (member.ParentData != null && ignoredBaseTypes.Contains(member.ParentData.FullName))
             {
                 continue;
             }
             
            properties.Add(MapToGeneratorPropertyModel(member));
        }

        // Add propertes from Custom DTOs (Base Classes mapped to DTOs)
        var customDTOProperties = GetCustomDTOProperties(data);
        foreach(var prop in customDTOProperties)
        {
            // Avoid duplicates if model already provided it (by name)
             if (!properties.Any(p => p.Name == prop.Name))
             {
                 properties.Add(prop);
             }
        }

        // Add NewName property if base class check matches (logic from GetClassMembers)
        if (data.Symbol.CheckBaseClass(Constants.Models.BaseMasterObjectFullName) && !data.Symbol.CheckBaseClass(Constants.Models.BaseAliasedMasterObjectFullName))
        {
             // Check if already added (e.g. from Custom DTO inheritance)
             if (!properties.Any(p => p.Name == "NewName"))
             {
                properties.Add(new GeneratorPropertyModel(
                    name: "NewName",
                    typeName: "string",
                    typeInfo: new GeneratorTypeModel(
                        name: "String",
                        ns: "System",
                        fullName: "System.String",
                        isEnum: false,
                        isReferenceType: true,
                        isString: true
                    )
                )
                {
                    XmlElementName = "NAME",
                    SerializeAsAttribute = true,
                    SerializeAsInnerText = false
                });
             }
        }

        return new GeneratorTypeModel(
            name: data.DTOName,
            ns: $"{data.Namespace}.DTO",
            fullName: data.DTOFullName,
            isEnum: data.IsEnum,
            isReferenceType: !data.IsEnum,

            isString: false // DTO is class
        )
        {
            Properties = [.. properties],
            ImplementsIXmlStreamable = true,
            Kind = PropertyKind.ComplexObject
        };
    }

    private List<GeneratorPropertyModel> GetCustomDTOProperties(ClassData data)
    {
        var results = new List<GeneratorPropertyModel>();
        var current = data.BaseData;
        while(current != null)
        {
            if (current.DTOSymbol != null)
            {
                var dtoClassData = new ClassData(current.DTOSymbol)
                {
                    DTOName = current.DTOSymbol.Name,
                    DTOFullName = current.DTOSymbol.ToDisplayString()
                };

                var members = current.DTOSymbol.GetMembers();
                foreach(var member in members)
                {
                    if (member is IPropertySymbol prop && prop.DeclaredAccessibility == Accessibility.Public && !prop.IsStatic)
                    {
                        var propData = new ClassPropertyData(prop, dtoClassData);
                        PropertyAttributesTransformer.TransformAsync(propData, prop.GetAttributes());
                        
                        var model = MapToGeneratorPropertyModel(propData);
                        if (model != null)
                        {
                            results.Add(model);
                        }
                    }
                }

            }
            current = current.BaseData;
        }
        return results;
    }



    private GeneratorPropertyModel MapToGeneratorPropertyModel(ClassPropertyData member)
    {
        // Determine Type Name
        string typeName = "string"; // Default
        bool isComplex = member.IsComplex && !member.IsTallyComplexObject;
        bool isList = member.IsList;

        GeneratorTypeModel typeInfo;

        if (isComplex)
        {
            if (member.ClassData != null)
            {
                typeName = $"{member.ClassData.Namespace}.DTO.{member.ClassData.DTOName}";
                typeInfo = MapToGeneratorTypeModel(member.ClassData);
            }
            else
            {
                typeName = member.PropertyOriginalType.ToDisplayString();
                typeInfo = new GeneratorTypeModel(
                    name: member.PropertyOriginalType.Name,
                    ns: member.PropertyOriginalType.ContainingNamespace.ToString(),
                    fullName: member.PropertyOriginalType.ToDisplayString(),
                    isEnum: member.PropertyOriginalType.TypeKind == TypeKind.Enum,
                    isReferenceType: member.PropertyOriginalType.IsReferenceType,
                    isString: member.PropertyOriginalType.SpecialType == SpecialType.System_String
                )
                {
                    Kind = PropertyKind.ComplexObject,
                    ImplementsIXmlStreamable = true
                };
            }
        }
        else if (isList)
        {
            if (member.ClassData != null)
            {
                // List of complex objects (Model-based)
                typeName = $"{member.ClassData.Namespace}.DTO.{member.ClassData.DTOName}"; 
                typeInfo = MapToGeneratorTypeModel(member.ClassData);
            }
            else
            {
                // List of complex objects (DTO-based) or primitives
                // member.PropertyOriginalType is already the ITEM TYPE for lists (see ClassPropertyData.GetChildType)
                var itemType = (INamedTypeSymbol)member.PropertyOriginalType;
                 typeName = itemType.ToDisplayString();
                 typeInfo = new GeneratorTypeModel(
                    name: itemType.Name,
                    ns: itemType.ContainingNamespace.ToString(),
                    fullName: itemType.ToDisplayString(),
                    isEnum: itemType.TypeKind == TypeKind.Enum,
                    isReferenceType: itemType.IsReferenceType,
                    isString: itemType.SpecialType == SpecialType.System_String
                )
                {
                    Kind = itemType.TypeKind == TypeKind.Enum ? PropertyKind.Enum :
                           (itemType.SpecialType == SpecialType.System_String || itemType.IsValueType) ? PropertyKind.Primitive : PropertyKind.ComplexObject,
                    ImplementsIXmlStreamable = true
                };
            }
        }
        else
        {
            // Primitive or simple
            var specialType = member.PropertyOriginalType.SpecialType;
            bool isEnum = member.IsEnum;

            typeName = isEnum ? member.PropertyOriginalType.ToString() : member.PropertyOriginalType.ToString();
            
            // Fix existing default-to-string logic
            // If it's enum, it is string in DTO
            if (isEnum || specialType == SpecialType.System_String)
            {
                typeInfo = new GeneratorTypeModel(
                    name: "String",
                    ns: "System",
                    fullName: "System.String",
                    isEnum: false,
                    isReferenceType: true,
                    isString: true
                );
                if (isEnum) typeName = "string";
            }
            else
            {
                 // Other primitives (int, bool, etc)
                 // Keep them as whatever they are?
                 // PostDTOGenerator often converts everything to string.
                 // But let's respect the type if intended.
                 // Existing code defaulted to String (lines 786-793).
                 // User code (previous block) had typeName = "string" at line 784.
                 
                 // Replicating original "everything is string" behavior for consistency with PostDTOGenerator legacy
                 typeName = "string";
                 typeInfo = new GeneratorTypeModel("String", "System", "System.String", false, true, true);
            }
        }

        string xmlTag = member.DefaultXMLData?.XmlTag ?? member.Name.ToUpper();
        // PostDTOGenerator uses XMLElementAttribute.

        var model = new GeneratorPropertyModel(
            name: member.Name,
            typeName: isList ? $"List<{typeName}>" : typeName,
            typeInfo: isList ? new GeneratorTypeModel("List", "System.Collections.Generic", "System.Collections.Generic.List", false, true, false) { Kind = PropertyKind.Collection } : typeInfo
        )
        {
            XmlElementName = xmlTag,
            SerializeAsAttribute = member.IsAttribute,
            AttributeName = member.IsAttribute ? xmlTag : null // Set attribute name if applicable
        };

        model.IsNullable = member.IsNullable;

        if (isList)
        {
            model.TypeInfo.Kind = PropertyKind.Collection;
            model.ItemTypeInfo = typeInfo;
            model.ArrayElementName = member.Name;
            if (member.ListXMLTag != null)
            {
                model.ArrayElementName = member.ListXMLTag;
                model.ArrayItemElementName = xmlTag;
            }
            else
            {
                model.ArrayElementName = null;
                model.ArrayItemElementName = xmlTag;
            }

            // Combine DefaultXMLData with XMLData for comprehensive polymorphic processing
            var allXmlData = new List<TallyConnector.TDLReportSourceGenerator.Models.XMLData>();
            if (member.DefaultXMLData != null)
            {
                allXmlData.Add(member.DefaultXMLData);
            }
            if (member.XMLData.Count > 0)
            {
                allXmlData.AddRange(member.XMLData);
            }

            // Check for polymorphism (multiple entries)
            if (allXmlData.Count > 0)
            {
                // Clear existing mappings if we are about to re-add them to avoid duplicates if any
                // model.PolymorphicMappings.Clear(); // Not needed as it's a new model

                var mappingDepths = new List<(PolymorphicMappingModel Map, int Depth)>();

                foreach (TallyConnector.TDLReportSourceGenerator.Models.XMLData data in allXmlData)
                {
                    // Use Symbol if present (from Type=...), otherwise fallback to property type (implicit)
                    var targetTypeSymbol = data.Symbol ?? (INamedTypeSymbol)member.PropertyOriginalType;
                    
                    // Construct Type Info / Name
                    string targetTypeName;
                    GeneratorTypeModel targetTypeInfo;

                    if (data.ClassData != null)
                    {
                         targetTypeName = data.ClassData.DTOFullName;
                         targetTypeInfo = MapToGeneratorTypeModel(data.ClassData);
                    }
                    else
                    {
                        bool isTargetComplex = targetTypeSymbol.TypeKind == TypeKind.Class && targetTypeSymbol.SpecialType != SpecialType.System_String;
                        if (isTargetComplex)
                        {
                            if (targetTypeSymbol.Name.EndsWith("DTO"))
                            {
                                targetTypeName = targetTypeSymbol.ToDisplayString();
                                targetTypeInfo = new GeneratorTypeModel(
                                    name: targetTypeSymbol.Name,
                                    ns: targetTypeSymbol.ContainingNamespace.ToString(),
                                    fullName: targetTypeName,
                                    isEnum: false,
                                    isReferenceType: true,
                                    isString: false
                                )
                                {
                                    Kind = PropertyKind.ComplexObject,
                                    ImplementsIXmlStreamable = true
                                };
                            }
                            else
                            {
                                targetTypeName = data.ClassData?.DTOFullName ?? $"{targetTypeSymbol.ContainingNamespace}.DTO.{targetTypeSymbol.Name}DTO";
                                targetTypeInfo = new GeneratorTypeModel(
                                    name: $"{targetTypeSymbol.Name}DTO",
                                    ns: member.ParentData.Namespace,
                                    fullName: targetTypeName,
                                    isEnum: false,
                                    isReferenceType: true,
                                    isString: false
                                )
                                {
                                    Kind = PropertyKind.ComplexObject,
                                    ImplementsIXmlStreamable = true
                                };
                            }
                        }
                        else
                        {
                            targetTypeName = targetTypeSymbol.ToDisplayString();
                            targetTypeInfo = new GeneratorTypeModel(
                                name: targetTypeSymbol.Name,
                                ns: member.ParentData.Namespace,
                                fullName: targetTypeSymbol.ToDisplayString(),
                                isEnum: targetTypeSymbol.TypeKind == TypeKind.Enum,
                                isReferenceType: targetTypeSymbol.IsReferenceType,
                                isString: targetTypeSymbol.SpecialType == SpecialType.System_String
                            )
                            {
                                Kind = targetTypeSymbol.TypeKind == TypeKind.Enum ? PropertyKind.Enum :
                                       (targetTypeSymbol.SpecialType == SpecialType.System_String || targetTypeSymbol.IsValueType) ? PropertyKind.Primitive : PropertyKind.ComplexObject,
                                ImplementsIXmlStreamable = false
                            };
                        }
                    }

                    var mapping = new PolymorphicMappingModel
                    {
                        XmlName = data.XmlTag ?? member.Name.ToUpper(),
                        TargetTypeName = targetTypeName,
                        ImplementsIXmlStreamable = targetTypeInfo.ImplementsIXmlStreamable,
                        TargetTypeInfo = targetTypeInfo
                    };

                    mappingDepths.Add((mapping, GetInheritanceDepth(targetTypeSymbol)));
                }

                // Sort by inheritance depth descending to ensure derived types are checked first
                foreach (var item in mappingDepths.OrderByDescending(x => x.Depth))
                {
                    model.PolymorphicMappings.Add(item.Map);
                }
            }
        }

        return model;
    }

    private static int GetInheritanceDepth(ITypeSymbol type)
    {
        int depth = 0;
        var current = type;
        while (current.BaseType != null)
        {
            depth++;
            current = current.BaseType;
        }
        return depth;
    }

    internal void GenerateEnumExtension()

    {
        ClassDeclarationSyntax classDeclarationSyntax = ClassDeclaration($"{_modelData.Name}HelperMethods")
                  .WithModifiers(TokenList([Token(
                            TriviaList(
                                Comment($@"/*
* Generated based on {_modelData.FullName}
*/")),
                            SyntaxKind.PublicKeyword,
                            TriviaList()),Token(SyntaxKind.StaticKeyword),Token(SyntaxKind.PartialKeyword)]));

        List<MemberDeclarationSyntax> members = [];
        List<SyntaxNodeOrToken> switchExpressions = [];
        foreach (var classProperty in _modelData.Members.Values)
        {
            switchExpressions.SafeAdd(SwitchExpressionArm(ConstantPattern(
                                       MemberAccessExpression(
                                           SyntaxKind.SimpleMemberAccessExpression,
                                           GetGlobalNameforType(_modelData.FullName),
                                           IdentifierName(classProperty.Name))),
                                   LiteralExpression(
                                       SyntaxKind.StringLiteralExpression,
                                       Literal(classProperty.DefaultXMLData?.EnumChoices.Last().Choice ?? string.Empty))));
        }

        members.Add(MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), "ToTallyString")
            .WithModifiers(TokenList([Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)]))
             .WithParameterList(
                ParameterList(
                    SingletonSeparatedList<ParameterSyntax>(
                        Parameter(
                            Identifier("src"))
                        .WithModifiers(
                            TokenList(
                                Token(SyntaxKind.ThisKeyword)))
                        .WithType(
                            GetGlobalNameforType(_modelData.FullName)))))
            .WithExpressionBody(ArrowExpressionClause(SwitchExpression(
                        IdentifierName("src")).WithArms(
                        SeparatedList<SwitchExpressionArmSyntax>(
                            switchExpressions))))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

        members.Add(MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), "ToTallyString")
            .WithModifiers(TokenList([Token(SyntaxKind.PublicKeyword), Token(SyntaxKind.StaticKeyword)]))
            .WithExpressionBody(ArrowExpressionClause(
                    ConditionalExpression(
                        IsPatternExpression(
                            IdentifierName("src"),
                            ConstantPattern(
                                LiteralExpression(
                                    SyntaxKind.NullLiteralExpression))),
                        LiteralExpression(
                            SyntaxKind.NullLiteralExpression),
                        InvocationExpression(
                            IdentifierName("ToTallyString"))
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList<ArgumentSyntax>(
                                    Argument(
                                        IdentifierName("src.Value"))))))))
             .WithParameterList(
                ParameterList(
                    SingletonSeparatedList<ParameterSyntax>(
                        Parameter(
                            Identifier("src"))
                        .WithModifiers(
                            TokenList(
                                Token(SyntaxKind.ThisKeyword)))
                        .WithType(
                           NullableType(GetGlobalNameforType(_modelData.FullName))))))
             .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));
        var unit = CompilationUnit()
       .WithMembers(List(new MemberDeclarationSyntax[]
       {
                FileScopedNamespaceDeclaration(IdentifierName(ExtensionsNameSpace))
                .WithNamespaceKeyword(Token(TriviaList(Trivia(NullableDirectiveTrivia(Token(SyntaxKind.EnableKeyword),true))),
                                            SyntaxKind.NamespaceKeyword,
                                            TriviaList()))
                .WithMembers(List(new MemberDeclarationSyntax[]
                {
                    classDeclarationSyntax
                    .WithMembers(List(members))
                }))
       })).NormalizeWhitespace().ToFullString();
        _context.AddSource($"EnumExt.{_modelData.Name}_{_modelData.Namespace}.g.cs", unit);
    }
}
